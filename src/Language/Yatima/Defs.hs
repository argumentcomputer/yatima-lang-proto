module Language.Yatima.Defs
  ( -- | IPFS content-identifiers
    module Language.Yatima.CID
  , Defs(..)
  , emptyDefs
  , Anon(..)
  , Meta(..)
  , AnonDef(..)
  , MetaDef(..)
  , DerefErr(..)
  , anonymize
  , separateMeta
  , MergeMetaErr(..)
  , mergeMeta
  ) where

import           Data.IntMap                (IntMap)
import qualified Data.IntMap                as IM
import           Data.Map                   (Map)
import qualified Data.Map                   as M
import           Data.Text                  (Text)
import qualified Data.Text                  as T hiding (find)
import qualified Data.ByteString.Lazy       as BSL

import           Codec.Serialise
import           Codec.Serialise.Decoding
import           Codec.Serialise.Encoding

import           Control.Monad.State.Strict
import           Control.Monad.Except

import           Language.Yatima.CID
import           Language.Yatima.Term

-- * Serialisation datatypes

-- | A content-addressed environment with an index of local names
data Defs = Defs { _index :: Map Name CID
                 , _cache :: Map CID BSL.ByteString
                 } deriving (Show, Eq)

emptyDefs :: Defs
emptyDefs = Defs M.empty M.empty

-- | An anonymized `Def`
data AnonDef = AnonDef
  { _termAnon :: CID
  , _typeAnon :: CID
  } deriving Show

-- | The metadata from a `Def`
data MetaDef = MetaDef
  { _anonDef   :: CID
  , _termMeta  :: Meta
  , _typeMeta  :: Meta
  }

-- | An anonymized `Term`
data Anon where
  VarA :: Int  -> Anon
  LamA :: Anon -> Anon
  AppA :: Anon -> Anon -> Anon
  RefA :: CID  -> Anon

deriving instance Show Anon

-- | A `Term`'s metadata
data Meta = Meta
  { _nams :: IntMap Name
  , _cids :: IntMap CID
  } deriving (Show,Eq)

-- * Serialisation utilities
-- | A helpful utility function like `when`, but with with pretty text errors
failM :: (Monad m, MonadFail m) => Bool -> [Text] -> m ()
failM c msg = if c then fail (T.unpack $ T.concat $ msg) else return ()

-- | A utility for erroring in a Decoder when we attempt to decode a field
decodeField :: Text -> Text -> Decoder s a -> Decoder s a
decodeField err nam decoder = do
  field <- decodeString
  failM (field /= nam)
    ["invalid ",err," field \"",field,"\"","expected \"",nam, "\"" ]
  decoder

-- | A utility for erroring in a Decoder when we attempt to decode a
-- constructor that matches one of a given set of names.
decodeCtor :: Text -> Text -> [Text] -> Decoder s Text
decodeCtor err field ns = do
  value <- decodeField err field decodeString
  failM (not $ value `elem` ns)
    ["invalid constructor tag at \"",field,"\""
    ,"expected one of: ",T.intercalate ", " ns
    ]
  return value

-- * Serialisation instance

-- | This encoding is designed to match the
-- [js-ipld-dag-cbor](https://github.com/ipld/js-ipld-dag-cbor) library's
-- encoding of the isomorphic JSON structure defined by:
--
-- > const Var = (indx)      => ({$0:"Var",$1:indx});
-- > const Ref = (cid)       => ({$0:"Ref",$1:cid});
-- > const Lam = (body)      => ({$0:"Lam",$1:body});
-- > const App = (func,argm) => ({$0:"App",$1:func,$2:argm});
encodeAnon :: Anon -> Encoding
encodeAnon term = case term of
  VarA idx             -> encodeMapLen 2
                          <> (encodeString "$0" <> encodeString "Var")
                          <> (encodeString "$1" <> encodeInt idx)
  RefA cid             -> encodeMapLen 2
                          <> (encodeString "$0" <> encodeString "Ref")
                          <> (encodeString "$1" <> encodeCID     cid)
  LamA bdy             -> encodeMapLen 2
                          <> (encodeString "$0" <> encodeString "Lam")
                          <> (encodeString "$1" <> encodeAnon bdy)
  AppA fun arg         -> encodeMapLen 3
                          <> (encodeString "$0" <> encodeString "App")
                          <> (encodeString "$1" <> encodeAnon    fun)
                          <> (encodeString "$2" <> encodeAnon    arg)

-- | Decode an `Encoding` generated by `encodeAnon`
decodeAnon :: Decoder s Anon
decodeAnon = do
  size <- decodeMapLen
  case size of
    2 -> do
      ctor <- decodeCtor "Anon" "$0" ["Var", "Ref", "Lam"]
      case ctor of
        "Var" -> VarA <$> decodeField "Var" "$1" decodeInt
        "Ref" -> RefA <$> decodeField "Ref" "$1" decodeCID
        "Lam" -> LamA <$> decodeField "Lam" "$1" decodeAnon
    3 -> do
      ctor <- decodeCtor "Anon" "$0" ["App"]
      case ctor of
        "App" -> AppA <$> decodeField "App" "$1" decodeAnon
                      <*> decodeField "App" "$2" decodeAnon
    _ -> fail "invalid map size"

instance Serialise Anon where
  encode = encodeAnon
  decode = decodeAnon

-- | This encoding is designed to match the
-- [js-ipld-dag-cbor](https://github.com/ipld/js-ipld-dag-cbor) library's
-- encoding of the isomorphic JSON structure defined by:
--
-- > const Meta = (nams, cids) => ({$0:"Meta", $1:nams, $2:cids})
--
-- where nams and locs are maps of integers to strings and `Loc`, using the
-- standard cborg map encoding.
encodeMeta :: Meta -> Encoding
encodeMeta (Meta ns ls) = encodeMapLen 3
    <> (encodeString "$0" <> encodeString "Meta")
    <> (encodeString "$1" <> encode ns)
    <> (encodeString "$2" <> encode ls)

-- | Decode an `Encoding` generate by `encodeMeta`
decodeMeta :: Decoder s Meta
decodeMeta = do
  size  <- decodeMapLen
  failM (size /= 3) ["invalid map size: ", T.pack $ show size]
  decodeCtor "Meta" "$0" ["Meta"]
  ns <- decodeField "Meta" "$1" decode
  ls <- decodeField "Meta" "$2" decode
  return $ Meta ns ls

instance Serialise Meta where
  encode = encodeMeta
  decode = decodeMeta

encodeAnonDef :: AnonDef -> Encoding
encodeAnonDef (AnonDef termAnon typeAnon ) = encodeMapLen 3
  <> (encodeString "$0" <> encodeString "AnonDef")
  <> (encodeString "$1" <> encodeCID  termAnon)
  <> (encodeString "$2" <> encodeCID  typeAnon)

decodeAnonDef :: Decoder s AnonDef
decodeAnonDef = do
  size     <- decodeMapLen
  failM (size /= 3) ["invalid map size: ", T.pack $ show size]

  decodeCtor "AnonDef" "$0" ["AnonDef"]

  termAnon <- decodeField "AnonDef" "$1" decodeCID
  typeAnon <- decodeField "AnonDef" "$2" decodeCID

  return $ AnonDef termAnon typeAnon

instance Serialise AnonDef where
  encode = encodeAnonDef
  decode = decodeAnonDef

encodeMetaDef :: MetaDef -> Encoding
encodeMetaDef (MetaDef anonDef termMeta typeMeta ) = encodeMapLen 4
  <> (encodeString "$0" <> encodeString "MetaDef")
  <> (encodeString "$1" <> encodeCID   anonDef)
  <> (encodeString "$2" <> encodeMeta  termMeta)
  <> (encodeString "$3" <> encodeMeta  typeMeta)

decodeMetaDef :: Decoder s MetaDef
decodeMetaDef = do
  size     <- decodeMapLen
  failM (size /= 4) ["invalid map size: ", T.pack $ show size]

  decodeCtor "MetaDef" "$0" ["MetaDef"]

  anonDef  <- decodeField "MetaDef" "$1" decodeCID
  termMeta <- decodeField "MetaDef" "$2" decodeMeta
  typeMeta <- decodeField "MetaDef" "$3" decodeMeta

  return $ MetaDef anonDef termMeta typeMeta

instance Serialise MetaDef where
  encode = encodeMetaDef
  decode = decodeMetaDef

-- * Anonymization

data DerefErr
  = NoDeserial DeserialiseFailure
  | NotInIndex Name
  | NotInCache CID
  | FreeVariable Name [Name]
  deriving (Eq,Show)

deriving instance Ord DeserialiseFailure
deriving instance Ord DerefErr

-- | Find a name in the binding context and return its index
find :: Name -> [Name] -> Maybe Int
find n cs = go n cs 0
  where
    go n (c:cs) i
      | n == c    = Just i
      | otherwise = go n cs (i+1)
    go _ [] _     = Nothing

-- | Anonymize a term
anonymize :: Name -> Term -> Defs -> Except DerefErr Anon
anonymize n t ds = go t [n]
  where
    go :: Term -> [Name] -> Except DerefErr Anon
    go t ctx = case t of
      Var n       -> case find n ctx of
        Just i -> return $ VarA i
        _      -> throwError $ FreeVariable n ctx
      Ref n       -> RefA <$> anonymizeRef n ds
      Lam n b     -> LamA <$> go b (n:ctx)
      App f a     -> AppA <$> go f ctx <*> go a ctx

anonymizeRef :: Name -> Defs -> Except DerefErr CID
anonymizeRef n ds = do
  mdCID   <- indexLookup n ds
  mdBytes <- cacheLookup mdCID ds
  metaDef <- either (throwError . NoDeserial) return (deserialiseOrFail mdBytes)
  return (_anonDef metaDef)

indexLookup :: Name -> Defs -> Except DerefErr CID
indexLookup n d = maybe (throwError $ NotInIndex n) pure ((_index d) M.!? n)

cacheLookup :: CID -> Defs -> Except DerefErr BSL.ByteString
cacheLookup c d = maybe (throwError $ NotInCache c) pure ((_cache d) M.!? c)

separateMeta :: Name -> Term -> Defs -> Except DerefErr (Anon, Meta)
separateMeta n t ds = do
  case runState (runExceptT (go t [n])) (Meta (IM.singleton 0 n) IM.empty, 1) of
    (Left  err,_)   -> throwError err
    (Right a,(m,_)) -> return (a,m)

  where
    bind :: Name -> ExceptT DerefErr (State (Meta,Int)) ()
    bind n = modify (\(Meta ns cs,i) -> (Meta (IM.insert i n ns) cs, i))

    cids :: CID -> ExceptT DerefErr (State (Meta,Int)) ()
    cids c = modify (\(Meta ns cs,i) -> (Meta ns (IM.insert i c cs), i))

    bump :: ExceptT DerefErr (State (Meta,Int)) ()
    bump = modify (\(m,i) -> (m, i+1))

    go :: Term -> [Name] -> ExceptT DerefErr (State (Meta,Int)) Anon
    go t ctx = case t of
      Var n       -> case find n ctx of
        Just i -> return $ VarA i
        _      -> throwError $ FreeVariable n ctx
      Ref n     -> do
        c <- liftEither . runExcept $ anonymizeRef n ds
        bind n >> cids c >> return (RefA c)
      Lam n b -> bind n >> bump >> LamA <$> go b (n:ctx)
      App f a -> bump >> AppA <$> go f ctx <*> go a ctx

-- | Find a name in the binding context and return its index
lookupName :: Int -> [Name] -> Maybe Name
lookupName i []     = Nothing
lookupName i (x:xs)
  | i < 0     = Nothing
  | i == 0    = Just x
  | otherwise = lookupName (i - 1) xs

data MergeMetaErr
  = MissingNameAt Int
  | FreeVariableAt Int [Name] Int

mergeMeta :: Anon -> Meta -> Except MergeMetaErr Term
mergeMeta anon meta = do
  defName <- maybe (throwError $ MissingNameAt 0) pure (_nams meta IM.!? 0)
  liftEither (evalState (runExceptT (go anon [defName])) 0)

  where
    bump :: ExceptT MergeMetaErr (State Int) ()
    bump = modify (+1)

    go :: Anon -> [Name] -> ExceptT MergeMetaErr (State Int) Term
    go t ctx = case t of
      VarA idx -> case lookupName idx ctx of
        Nothing -> get >>= (\i -> throwError $ FreeVariableAt i ctx idx)
        Just n  -> return $ Var n
      RefA cid -> do
        i <- get
        n <- maybe (throwError $ MissingNameAt i) pure (_nams meta IM.!? i)
        return $ Ref n
      LamA b  -> do
        i <- get
        n <- maybe (throwError $ MissingNameAt i) pure (_nams meta IM.!? i)
        bump
        Lam n <$> go b (n:ctx)
      AppA f a -> bump >> App <$> go f ctx <*> go a ctx
