package Array
  with Nat
  with Unit as U
  with Pair as P
  where

def Array (A : *) (dep : Nat) : * 
  = ∀.self
  (0 P : ∀ (dep : Nat) (arr : Array A dep) -> *)
  (& leaf   : ∀ (a : A) -> (P zero (λ P l b => l a)))
  (& branch : ∀ (0 dep : Nat) (& lft : Array A dep) (& rgt : Array A dep) -> (P (succ dep) (λ P l b => b dep lft rgt)))
  -> P dep self

def leaf (0 A : *) (a : A) : Array A zero =
  λ P l b => l a

def branch (0 A : *) (0 dep : Nat) (& lft : Array A dep) (& rgt : Array A dep) : Array A (succ dep) =
  λ P l b => b dep lft rgt

-- Creates an array of depth `depth` and initial value `x`.
def alloc (0 A : *) (depth : Nat) (x : A) : (Array A depth) =
  depth
    (λ self => Array A self)
    (leaf A x)
    (λ pred =>
      let half : (Array A pred) = alloc A pred x;
      branch A pred half half)
